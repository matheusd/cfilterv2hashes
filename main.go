// Copyright (c) 2014-2015 The btcsuite developers
// Copyright (c) 2015-2019 The Decred developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package main

import (
	"crypto/sha256"
	"errors"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/decred/dcrd/dcrutil/v3"
	"github.com/decred/dcrd/gcs/v2"
	"github.com/decred/dcrd/rpcclient/v5"
	"github.com/jessevdk/go-flags"
	"golang.org/x/sync/errgroup"
)

type config struct {
	RPCUser      string `short:"u" long:"rpcuser" description:"Username for RPC connections"`
	RPCPass      string `short:"P" long:"rpcpass" description:"Password for RPC connections"`
	RPCCert      string `long:"rpccert" description:"File containing the certificate file"`
	RPCConnect   string `short:"c" long:"rpcconnect" description:"Network address of dcrd RPC server"`
	TargetHeight uint64 `short:"t" long:"targetheight" description:"Target height to generate cfilters for. If empty, generates up to tip."`
	TestNet      bool   `long:"testnet" description:"Use the test network"`
}

type dcrdConfig struct {
	RPCUser string `short:"u" long:"rpcuser" description:"Username for RPC connections"`
	RPCPass string `short:"P" long:"rpcpass" description:"Password for RPC connections"`
	RPCCert string `long:"rpccert" description:"File containing the certificate file"`
	TestNet bool   `long:"testnet" description:"Use the test network"`
}

func main() {
	dcrdHomeDir := dcrutil.AppDataDir("dcrd", false)
	opts := &config{
		RPCCert: filepath.Join(dcrdHomeDir, "rpc.cert"),
	}
	dcrdCfgFile := filepath.Join(dcrdHomeDir, "dcrd.conf")
	if _, err := os.Stat(dcrdCfgFile); err == nil {
		// ~/.dcrd/dcrd.conf exists. Read precfg data from it.
		dcrdOpts := &dcrdConfig{}
		parser := flags.NewParser(dcrdOpts, flags.Default)
		err := flags.NewIniParser(parser).ParseFile(dcrdCfgFile)
		if err == nil {
			opts.RPCUser = dcrdOpts.RPCUser
			opts.RPCPass = dcrdOpts.RPCPass
			switch {
			case dcrdOpts.TestNet:
				opts.RPCConnect = "localhost:19109"
				opts.TestNet = true
			default:
				opts.RPCConnect = "localhost:9109"
			}
		}
	}

	parser := flags.NewParser(opts, flags.Default)
	_, err := parser.Parse()
	if err != nil {
		var e *flags.Error
		if errors.As(err, &e) && e.Type == flags.ErrHelp {
			os.Exit(0)
		}
		parser.WriteHelp(os.Stderr)
		return
	}

	// Connect to local dcrd RPC server using websockets.
	certs, err := ioutil.ReadFile(opts.RPCCert)
	if err != nil {
		log.Fatal(err)
	}
	connCfg := &rpcclient.ConnConfig{
		Host:         opts.RPCConnect,
		Endpoint:     "ws",
		User:         opts.RPCUser,
		Pass:         opts.RPCPass,
		Certificates: certs,
	}
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Fatal(err)
	}

	// Get the current block count.
	blockCount, err := client.GetBlockCount()
	if err != nil {
		log.Fatal(err)
	}

	if blockCount < int64(opts.TargetHeight) {
		log.Fatalf("Cannot generate up to %d when block count is %d",
			opts.TargetHeight, blockCount)
	}
	if opts.TargetHeight == 0 {
		opts.TargetHeight = uint64(blockCount)
	}

	network := "mainnet"
	if opts.TestNet {
		network = "testnet3"
	}

	// Request cfilters in batches of 'step' blocks at a time since
	// fetching them is the slowest operation.
	step := int64(4000)
	cfilters := make([]*gcs.FilterV2, step)

	// Keep track of the hash of the full set of cfilter hashes so other
	// people can verify them easily.
	hasher := sha256.New()

	log.Printf("Generating up to block %d for %s", opts.TargetHeight, network)
	target := int64(opts.TargetHeight)

	var out strings.Builder
	out.WriteString("// Autogenerated by github.com/matheusd/cfiltersv2hashes\n\n")
	out.WriteString("package validate\n\n")
	out.WriteString(fmt.Sprintf("const cfilterv2RawHashes_%s string = \"", network))

	var totalCFilterSize int64
	for h := int64(0); h <= target; h += step {

		// Fetch either a batch of size 'step' cfilters or only as many
		// as needed to reach the target height.
		if h+step > target {
			step = target - h + 1
			cfilters = cfilters[:step]
		}

		// Do so concurrently.
		var g errgroup.Group
		for i := int64(0); i < step; i++ {
			i := i
			g.Go(func() error {
				bh, err := client.GetBlockHash(h + i)
				if err != nil {
					return err
				}

				f, err := client.GetCFilterV2(bh)
				if err != nil {
					return err
				}
				cfilters[i] = f.Filter
				return nil
			})
		}
		err := g.Wait()
		if err != nil {
			log.Fatal(err)
		}

		// Now for every cfilter received, write out its hex
		// representation in the output string and keep track of the
		// stats.
		for i, cf := range cfilters {
			fh := cf.Hash()
			out.WriteString(fmt.Sprintf("%s", fh.String()))

			totalCFilterSize += int64(len(cf.Bytes()))
			hasher.Write(fh[:])

			// Report on progress.
			if (h+int64(i))%10000 == 0 {
				log.Printf("Generated up to height %d", h+int64(i))
			}
		}
	}
	out.WriteString("\"\n")

	formatted, err := format.Source([]byte(out.String()))
	if err != nil {
		log.Fatalf("Error formatting resulting code: %v", err)
	}
	fmt.Println(string(formatted))

	log.Printf("SHA-256 of raw data: %x\n", hasher.Sum(nil))
	log.Printf("Total CFilter size: %.2f MiB\n", float64(totalCFilterSize)/1024/1024)
	log.Printf("Avg CFilter size: %d bytes\n", totalCFilterSize/target)

	client.Shutdown()
}
